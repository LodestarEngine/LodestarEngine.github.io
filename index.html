<!-- (c) by Hamza El-Kebir

This work is licensed under a
Creative Commons Attribution 4.0 International License.

You should have received a copy of the license along with this
work. If not, see <http://creativecommons.org/licenses/by/4.0/>. -->
<meta charset="utf-8" lang="en"><style class="fallback">body{visibility:hidden;}</style>

                **Lodestar: An Unabridged Rationale**
                            Hamza El-Kebir

![Lodestar logo.](img/LodestarLogoOnly.png width="17%") In this
page[^lastupdated], I describe in detail the rationale and philosophy
that underpins the development of
[Lodestar](https://github.com/helkebir/Lodestar), an open-source
real-time C++ control library.

The greatest driver behind this project is the lack of a fast and
accessible library for applying control theoretic concepts on real-life
(embedded) systems. While platforms such as
[ROS](https://www.ros.org/)[^ros] are popular in robotics, people
working with applications that require real-time viable code and thread
safety are often compelled to write their own solutions, with propertary
implementations being the norm, and a single unified solution is left to
be desired.

With this in mind, I set out to develop a unified and approachable
control library, with the explicit intention to make it as real-time
viable as possible while maintaining code transparency and providing a
flexible API[^api].

!!! WARNING
    This page is still under construction.

[^lastupdated]: _Last updated_: June 5, 2021

Core Principles
========================================================================

Lodestar is built on the following core principles:

1. ***Firm real-time* first**:
    * Memory demands should be known at compile-time, minimum/no dynamic
        memory allocation/paging.
    * Dynamically and statically allocated objects should share a common
        API.
    * Exceptions should be thrown with care; status-based fallbacks are
        preferred.
    * Processes should be timed, with fallback mechanisms and deadline
        violation reporting.
2. **Wide platform support**:
    * Maintain minimum demands should be imposed on compiled libraries,
        preferring header-only libraries instead.
    * Use only ISO/ANSI C++11 features.
    * Make full use of POSIX[^posix] RT (real-time) mechanisms
        (`pthread`s, `sigaction`s, etc.). 
3. **Flexible interfacing and extension**:
    * Extendible, documented, and transparent core API.
    * Inproc and outproc non-blocking communication framework.
    * Thread-safe data types, with object-bound `mutex`es.

Levels of Real-time
------------------------------------------------------------------------

1. **Soft real-time**: Delayed process completion may degrade a system's
    quality of service, but is tolerable.
2. **Firm real-time**: Delayed process completion may degrade a system's
    quality of service, but is tolerable if infrequent.
3. **Firm real-time**: Delayed process completion results in system
    failure.

What Constitutes Control?
------------------------------------------------------------------------

!!! WARNING
    Opinions ahead.

Code Style
========================================================================

~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
#ifndef LODESTAR_CONTAINER_HPP
#define LODESTAR_CONTAINER_HPP

#include &lt;array&gt;
// Note that we do not use `using std` to limit namespace pollution/clashes

// Preprocessor directives and their arguments should be in upper snake case 
#define STATIC_GET(ARRAY, IDX) std::get&lt;IDX&gt;(ARRAY)

// Template arguments should be descriptive, written in upper camel case, and prefixed with T*
template &lt;typename TType&gt;
// Constexpr should be prefixed with K*, and the following word should be in lower camel case.
constexpr TType &Kmax(const TType &a, const TType &b)
{   // K&R-style brace placement (preceded by a linebreak) for functions
    // Indents are 4 spaces deep
    return (int &) (a > b ? a : b);
}

// Global variables follow the same naming rules as other variables
// Constant variables are prefixed with k*
const static unsigned int kDefaultSize = 10;

template &lt;typename TType, unsigned int TSize = kDefaultSize&gt;
// Class names should be in upper camel case
class Container {
public:
    // Typedefs should be descriptive and are prefixed with TD*
    typedef std::array&lt;TType, TSize&gt; TDArray;

    Container() : array_(TDArray{}) {}

    explicit Container(const TDArray &array) : array_(array) {}

    explicit Container(const TDArray *array) : array_(*array) {}

    Container(const TDArray &array, const unsigned int end) : array_(TDArray{})
    {
        unsigned int i = 0;
        while ((i < end) && (i < TSize)) {
            array_[i] = array[i];
            i++;
        }
    }

    // Use of lower camel case names is encouraged
    void clearArray()
    {
        for (unsigned int i = 0; i < TSize; i++)
            array_[i] = TType{};
    }

    TType getElement(const unsigned int idx) const
    {
        return array_[idx];
    }

    void setElement(const unsigned int idx, const TType &val)
    {
        array_[idx] = val;
    }

    TDArray copyArray() const {
        return array_;
    }

    void copyContainer(const Container &other) const
    {
        for (unsigned int i = 0; i < TSize; i++)
            array_[i] = other.getElement(i);
    }

    TType getFirst() const
    {
        return STATIC_GET(array_, 0);
    }

    TType getLast() const
    {
        return STATIC_GET(array_, Kmax(0, TSize - 1));
    }

    const unsigned int kSize = TSize;
protected:
    // Private/protected member variables are postfixed with *_
    std::array&lt;TType, TSize&gt; array_;

    // Static members may be prefixed with z* in case of ambiguities
    template&lt;unsigned int TSizeOther&gt;
    Container&lt;TType, TSize&gt; zCopyContainer(const Container&lt;TType, TSizeOther&gt; &other)
    {
        Container&lt;TType, TSize&gt; container{};

        unsigned int i = 0;
        while ((i < other.kSize) && (i < TSize))
            container.setElement(i, other.getElement(i));
        
        return container;
    }
}

// Preprocessor directives should be undef'd if they are not part of the public API
#undef STATIC_GET

#endif //LODESTAR_CONTAINER_HPP
~~~~~~~~~~~~~~~~~~~~~~~
[Listing [styleexample]: A code style example.]

Letter Prefixes
------------------------------------------------------------------------

The letter 'k' is used to denote constant
(<code lang=C++>const</code>, /ˈkɑnst/) variables, whereas 'K' is
reserved for constant expressions (<code lang=C++>constexpr</code>); 'k'
is the 5th least frequently used letter in English[^letterfreq].

The letter 'z' is used to denoted static functions or variables whenever
deemed necessary, because of its morphological similarity to 's'; 'z' is
the least frequently used letter in English[^letterfreq].

[^letterfreq]: See [_Letter frequency_](https://en.wikipedia.org/wiki/Letter_frequency),
    Wikipedia. We consider the frequency in texts.

Underscores
------------------------------------------------------------------------

Sometimes, prefixed underscores are used to denote private/protected
member variables. In some cases, this can lead to clashes with reserved
C/C++ symbols used by implementation macros. Most notably, this includes
`_X*` (where `X` is any capital letter) and `__*`; in the global
namespace, `_*` is reserved in general[^reservedsymbols].

For this reason, `*_` as a suffix poses an easy spec-compliant
alternative for denoting private/protected member variables.

[^reservedsymbols]: C++03 Sec. 17.4.3.1.2 on global names, and C99 
    Sec. 7.1.3 on reserved identifiers; see
    [this answer on StackOverflow](https://stackoverflow.com/a/228797)
    for an excellent summary.

Architecture
========================================================================

Blocks
------------------------------------------------------------------------


************************************
*         .---------.              *
*  I0 *-->|         +-->o O0       *
*  I1 *-->|  BLOCK  +-->o O1       *
*  I2 *-->|         +-->o O2       *
*         '---------'              *
*                                  *
*         .--> CB_I0_0 --.         *
*  I0 *--+---> CB_I0_1 ---+-->o O0 *
*        +---> CB_I0_2 --'         *
*         '--> CB_I0_3 --+--->o O1 *
*                         '-->o O2 *
************************************
[Figure [block]: Block with callbacks.]

~~~~~~~~~~~~~~~~~~~ C++ linenumbers
auto block = Block&lt;std::tuple&lt;int, double, bool&gt;, std::tuple&lt;double, double, double&gt;&gt;{};

block.setInput&lt;0&gt; = 0;
block.setInput&lt;1&gt; = 3;
block.setInput&lt;2&gt; = true;

std::function&lt;bool(int)&gt; cbI0_0 = [&block](int i0) {
    if (block.getInput&lt;2&gt;())
        block.setOutput&lt;0&gt;(block.getOutput&lt;0&gt;() + i0 + block.getInput&lt;1&gt;());
    else
        block.setOutput&lt;0&gt;(block.getOutput&lt;0&gt;() - i0 + block.getInput&lt;1&gt;());
    
    return true;
};

block.setInputCallback&lt;0&gt;(cbI0_0, 0);
block.setInputCallback&lt;0&gt;(cbI0_0, 1);
block.setInputCallback&lt;0&gt;(cbI0_0, 2);

std::function&lt;bool(int)&gt; cbI0_3 = [&block](int i0) {
    block.setOutput&lt;1&gt;(block.getOutput&lt;0&gt;() + i0);
    block.setOutput&lt;2&gt;(block.getOutput&lt;1&gt;() + i0);
    
    return true;
};

block.setInputCallback&lt;0&gt;(cbI0_3, 3);

block.setInput&lt;0&gt; = 1;

std::cout &lt;&lt; "O0: " &lt;&lt; block.getOutput&lt;0&gt;() &lt;&lt; std::endl;
std::cout &lt;&lt; "O1: " &lt;&lt; block.getOutput&lt;1&gt;() &lt;&lt; std::endl;
std::cout &lt;&lt; "O2: " &lt;&lt; block.getOutput&lt;2&gt;() &lt;&lt; std::endl;

//> O0: 12
//> O1: 13
//> O2: 4
~~~~~~~~~~~~~~~~~~~
[Listing [blockcode]: An example of a Block implementation.]

Messages
------------------------------------------------------------------------

We use [nanopb](https://jpa.kapsi.fi/nanopb/), a light-weight
header-only implementation of Google's
[Protocol Buffers](https://developers.google.com/protocol-buffers)
(protobuf) for serialization.

Nanopb provides a number of advantages over vanilla protobuf in the
context of embedded and real-time systems. The main advantage lies in
the fact that dynamic types can be constrained to have a fixed maximum
length. As an example, a `string` object may have abitrary length,
whereas if we constrain it to be of length 16 characters, we can
allocate it as <code lang=C++>char[17]</code> instead (the `+1` comes
from <code lang=C++>'\0'</code>). This provides yet another mechanism to
statically allocated memory at compile time.

Thread Safety
------------------------------------------------------------------------

(##) Glossary

*Terms are listed in order of first appearance.*

[^ros]: **ROS**: Robot Operating System.

[^api]: **API**: Application programmer interface.

[^posix]: **POSIX**: Portable Operating System Interface, a family of standards
described in IEEE 1003 and ISO/IEC 9945.


<!-- Markdeep: --><script src="markdeep.js" charset="utf-8"></script>
